# 图片代理接口说明

## 问题背景

飞书API返回的图片是下载链接，不能直接在浏览器HTML中使用img标签展示。飞书下载图片需要在请求头中添加Authorization信息：

```bash
curl --location --request GET 'https://base-api.feishu.cn/open-apis/drive/v1/medias/:file_token/download' \
--header 'Authorization: Bearer token'
```

## 解决方案

实现一个图片代理接口 `/api/v1/img/:file_token`，通过后端程序自动添加认证头获取图片，然后流式传输给前端。

## 技术实现

### 1. 代理接口设计

**接口路径**: `/api/v1/img/<file_token>`
**请求方法**: GET
**功能**: 代理飞书图片下载，自动添加认证头

### 2. 核心实现

```python
@api_v1.route('/img/<file_token>', methods=['GET'])
def proxy_image(file_token):
    """图片代理接口"""
    try:
        # 构建飞书图片下载URL
        feishu_url = f"https://base-api.feishu.cn/open-apis/drive/v1/medias/{file_token}/download"
        
        # 使用FeishuService的认证头
        headers = feishu_service._get_headers()
        headers['User-Agent'] = 'Farm-Traceability-System/1.0'
        
        # 发起代理请求
        response = requests.get(feishu_url, headers=headers, stream=True, timeout=30)
        
        if response.status_code == 200:
            # 流式传输图片数据
            def generate():
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        yield chunk
            
            # 设置响应头
            response_headers = {
                'Content-Type': response.headers.get('Content-Type', 'image/jpeg'),
                'Cache-Control': 'public, max-age=3600',  # 缓存1小时
                'Access-Control-Allow-Origin': '*'  # 允许跨域
            }
            
            return Response(generate(), headers=response_headers)
        
    except Exception as e:
        # 错误处理
        return jsonify({'code': 1, 'message': f'图片代理失败: {str(e)}'}), 500
```

### 3. 关键技术点

#### 正确的API域名
- ✅ 使用 `base-api.feishu.cn` 
- ❌ 不要使用 `open.feishu.cn`

#### 认证方式
- 使用Personal Token（以`pt-`开头）
- 通过`Authorization: Bearer {token}`头部传递

#### 流式传输
- 使用`stream=True`避免大文件内存占用
- 通过`iter_content(chunk_size=8192)`分块传输
- 使用Flask的`Response`对象流式返回

#### 缓存策略
- 设置`Cache-Control: public, max-age=3600`
- 浏览器缓存1小时，减少重复请求

## 前端使用

### 1. JavaScript图片URL处理

```javascript
getImageUrl(image) {
    if (typeof image === 'string') {
        return image;
    } else if (image && typeof image === 'object') {
        // 如果有file_token，使用代理接口
        if (image.file_token) {
            return `/api/v1/img/${image.file_token}`;
        }
        // 否则使用原始URL
        return image.url || image.tmp_url || image.name || '';
    }
    return '';
}
```

### 2. HTML模板使用

```html
<!-- 动态图片显示 -->
<img v-if="farmData.product_info && farmData.product_info.首图" 
     :src="getImageUrl(farmData.product_info.首图)" 
     alt="农家散养土鸡" 
     class="chicken-image">

<!-- 饲喂记录图片 -->
<img v-if="record.images && record.images.length > 0" 
     :src="getImageUrl(record.images[0])" 
     :alt="record.food_name + '喂养'" 
     class="record-photo">
```

## 功能特性

### 1. 无存储设计
- ✅ 不在服务器存储图片文件
- ✅ 实时从飞书获取最新图片
- ✅ 节省服务器存储空间

### 2. 安全性
- ✅ 隐藏飞书API认证信息
- ✅ 前端无需处理认证逻辑
- ✅ 统一的访问控制

### 3. 性能优化
- ✅ 流式传输，支持大文件
- ✅ 浏览器缓存，减少重复请求
- ✅ 超时控制，避免长时间等待

### 4. 错误处理
- ✅ 网络超时处理
- ✅ 认证失败处理
- ✅ 文件不存在处理
- ✅ 详细的错误日志

## 使用示例

### 1. 直接访问图片
```
http://127.0.0.1:5000/api/v1/img/GDiZb3UvJos7XAxm1f8crccwnng
```

### 2. 在HTML中使用
```html
<img src="/api/v1/img/GDiZb3UvJos7XAxm1f8crccwnng" alt="图片">
```

### 3. 测试页面
```
http://127.0.0.1:5000/image-test.html
```

## 测试验证

### 1. 接口测试
```bash
# 获取图片头信息
curl -I "http://127.0.0.1:5000/api/v1/img/GDiZb3UvJos7XAxm1f8crccwnng"

# 下载图片文件
curl -o test.png "http://127.0.0.1:5000/api/v1/img/GDiZb3UvJos7XAxm1f8crccwnng"
```

### 2. 响应示例
```
HTTP/1.1 200 OK
Content-Type: image/png
Cache-Control: public, max-age=3600
Access-Control-Allow-Origin: *
Content-Length: 608942
```

## 优势总结

1. **简单易用**: 前端只需要标准的img标签
2. **无存储**: 不占用服务器存储空间
3. **实时性**: 图片始终是最新的
4. **安全性**: 隐藏认证信息
5. **高性能**: 流式传输和缓存优化
6. **可扩展**: 支持各种图片格式和大小

## 注意事项

1. **网络依赖**: 需要稳定的飞书API连接
2. **认证有效性**: Personal Token需要保持有效
3. **流量考虑**: 大量图片访问会产生API调用
4. **缓存策略**: 可根据需要调整缓存时间
